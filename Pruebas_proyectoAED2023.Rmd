---
title: "Pruebas ProyectoAED2023"
output: html_document
date: "2023-10-12"
---

```{r}
library(readr)
library(readxl)
```

```{r}
hogar <- read.csv("./data/datos_hogares_2020/ECHHogares_2020.csv", sep = "\t")
persona <- read.csv("./data/datos_personas_2020/ECHPersonas_2020.csv", sep = "\t")
dic_hogar <- read_xlsx("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", skip = 1)
dic_hogar_t1 <- read_xlsx("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = 2)
dic_hogar_t2 <- read_xlsx("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = 3)
dic_persona <- read_xlsx("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", skip = 1)
dic_persona_t1 <- read_xlsx("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = 2)
dic_persona_t2 <- read_xlsx("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = 3)
dic_persona_t3 <- read_xlsx("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = 4)
```

El siguiente bloque de código se encarga de reemplazar todos los términos con un diccionario asociado. Tarda bastante en ejecutarse, supongo que por la cantidad de filas y columnas y la longitud de lo que tiene que reemplazar. Lo dejo para todas las columnas, pero se puede especificar para que actúe sobre las que queramos.

```{r}
for (i in seq_len(nrow(dic_hogar))) {
  if (!is.na(dic_hogar$`Diccionario ubicado en la hoja…`[i])){
    
    # If the variable has a dictionary, print the name of the sheet where it is located
    
    cat(sprintf("Variable %s has dictionary located in sheet %s\n", dic_hogar$Variable[i], dic_hogar$`Diccionario ubicado en la hoja…`[i]))
    
    if(dic_hogar$`Diccionario ubicado en la hoja…`[i] == "Tablas1"){
      consult <- dic_hogar_t1
      # Find the row index where the word is found
      start_row <- which(consult$`En hoja -Diseño-. Variables:` == dic_hogar$Variable[i])
      # Find the row index where NA is found after the word
      for(fila in start_row:length(consult[[1]])){
        if(is.na(consult[[1]][fila]) == T){
          end_row <- fila
          break
        }else {
          end_row <- fila
        }
      }
      
      # Select the subset of rows between the word and the first NA
      subset_df <- consult[start_row:end_row, ]
      subset_df[[1]] <- as.numeric(subset_df[[1]])
      
      for(j in 1:length(hogar[[dic_hogar$Variable[i]]])){
       if (is.na(hogar[[dic_hogar$Variable[i]]][j]) == T){
          next
        }else{
        hogar[[dic_hogar$Variable[i]]][j] <- subset_df[[2]][which(subset_df[1] == hogar[[dic_hogar$Variable[i]]][j])]
        }
      }
    
    
   }else if(dic_hogar$`Diccionario ubicado en la hoja…`[i] == "Tablas2"){
    
      consult <- dic_hogar_t2
      # Find the row index where the word is found
      start_row <- which(consult$`En hoja -Diseño-. Variables:` == dic_hogar$Variable[i])
      # Find the row index where NA is found after the word
      for(fila in start_row:length(consult[[1]])){
        if(is.na(consult[[1]][fila]) == T){
          end_row <- fila
          break
        }else {
          end_row <- fila
        }
      }
      
      # Select the subset of rows between the word and the first NA
      subset_df <- consult[start_row:end_row, ]
      subset_df[[1]] <- as.numeric(subset_df[[1]])
      
      for(j in 1:length(hogar[[dic_hogar$Variable[i]]])){
        if (is.na(hogar[[dic_hogar$Variable[i]]][j]) == T){
          next
        }else{
        hogar[[dic_hogar$Variable[i]]][j] <- subset_df[[2]][which(subset_df[1] == hogar[[dic_hogar$Variable[i]]][j])]
        }
      }
      
   }else {
    # If the variable does not have a dictionary, print a message indicating so
    cat(sprintf("Variable %s does not have a dictionary\n", dic_hogar$Variable[i]))
  }
 }
}
```

Vamos a tratar de realizar un primer análisis exploratorio del DataSet **hogar**. Para ello, en primer lugar observaremos las columnas del DataSet y el tipo de elementos que contienen

```{r}
str(hogar)
```
Además de un alista con las distintas columnas y sus tipos de datos, podemos generar un resumen con distintos estadísticos para cada una de las variables

```{r}
summary(hogar)
```
Esta función también nos permite observar qué columnas contienen NA's, información que nos será útil a futuro de cara a limpiar nuestro DataSet o trabajar con los datos

Como podemos observar, hay muchas columnas que contienen índices que no reflejan la información como tal, si no que hacen referencia a una escala externa, presente en otro documento. Además, hay ciertos nombres de variable que no son del todo claros, los cambiaremos para que sean más representativos. Lo que haremos a continuación será obtener la información real


```{r}
# En este chunK de código voy a poner, comentado para saber que hay que modificarlo o borrarlo, info relevante acerca de los campos, para no tener que mirarla en el fichero director

#IDENTIFICACIÓN DE LA VIVIENDA-----------------------------------------------------------------------------------------------------------

# PERIODO -> Periodo de recogida de la vivienda (formato -> aaaan; año + n-trimestre)
# TAMANO -> Tamaño del municipio (índice por habitantes -> valores en doc director)
# IDQ_PV -> Provincia (índices por porvincia -> valores en doc director)
# CA -> Comunidad autonoma (IDEM provincia)
# FACCAL -> Factor de elevación calibrado (formato numerico -> nnnnnn.nnnnnn)

#CARACTERÍSTICAS DE LA VIVIENDA----------------------------------------------------------------------------------------------------------

# REGVI -> Régimen de tenencia, es decir alquilada,, hipoteca, etc (índices por tipo -> valores en doc director)
# COCINA -> Disponibilidad de cocina (1 -> Sí ; 6 -> No)
# NHABVI -> Número de habitaciones
# METROSVI -> Metros cuadrados útiles en la vivienda

#CARACTERÍSTICAS DEL EDIFICIO------------------------------------------------------------------------------------------------------------

# TIPOVIV -> Tipo de edificio  (índices 1-6 -> valores en doc director)
# ANEDI -> Año de construcción (índices 1-9 -> valores en doc director)
# ANOANEDI -> Año de cosntrucción (solo valores del 20021 al 2020)
# FEDI -> Fecha de construcción (índices 01 - 11 -> valores en doc director)

#CARACTERÍSTICAS DEL HOGAR---------------------------------------------------------------------------------------------------------------

# TIP0HO -> Tipo de hogar (índices 1-16 -> valores en doc director)


```


```{r}
#librerias
library(readr)
library(readxl)
library(dplyr)
library(tidyr)
```


```{r}
hogar <- read.csv("./data/datos_hogares_2020/ECHHogares_2020.csv", sep = "\t")
persona <- read.csv("./data/datos_personas_2020/ECHPersonas_2020.csv", sep = "\t")
```

Tenemos un diccionario para leer los datos, lo vamos a intentar usar para leer los datos con el formato deseado:
```{r}
dic <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", skip = 1)

tab1 <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = "Tablas1", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab1) <- c("Cod", "Desc", "Var")
ind <- which(tab1$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab1[(ind[i]-1):nrow(tab1), "Var"] <- tab1[ind[i]-1, 3]
    tab1[(ind[i]-1):nrow(tab1), "New_Var"] <- tab1[ind[i]-1, 1]
  } else {
    tab1[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab1[ind[i]-1, 3]
    tab1[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab1[ind[i]-1, 1]
  }
}
I <- (!is.na(tab1$Cod != "Código") & tab1$Cod != "Código")
tab1 <- tab1[I, ]

J <- (!is.na(tab1$Desc))
tab1 <- tab1[J, ]

tab2 <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = "Tablas2", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab2) <- c("Cod", "Desc", "Var")
ind <- which(tab2$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab2[(ind[i]-1):nrow(tab2), "Var"] <- tab2[ind[i]-1, 3]
    tab2[(ind[i]-1):nrow(tab2), "New_Var"] <- tab2[ind[i]-1, 1]
  } else {
    tab2[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab2[ind[i]-1, 3]
    tab2[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab2[ind[i]-1, 1]
  }
}
I <- (!is.na(tab2$Cod != "Código") & tab2$Cod != "Código")
tab2 <- tab2[I, ]

J <- (!is.na(tab2$Desc))
tab2 <- tab2[J, ]

tab <- full_join(tab1, tab2)

tab$Cod <- as.numeric(as.character(tab$Cod))

for (i in names(hogar)){
  #el vector pos es el que contiene las posiciones de tab que contienen info sobre esa variable
  pos <- which(tab$Var == i)
  #el if es porque hay variables que no están en la tabla
  if (length(pos)>0){
    #ahora tenemos que sustituir el código por lo que toca
    for (j in seq(1, length(pos))){
      #el vector cod contiene las posiciones de hogar que tienen el mismo código para así poder sustituirlos
      cod <- which(hogar[,i] == tab$Cod[pos[j]])
      hogar[cod, i] <- tab$Desc[pos[j]]
    }
  }
}

```


