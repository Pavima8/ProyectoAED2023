---
title: "Pruebas ProyectoAED2023"
output: html_document
date: "2023-10-12"
---

```{r}
library(readr)
library(readxl)
```

```{r}
# En este chunK de código voy a poner, comentado para saber que hay que modificarlo o borrarlo, info relevante acerca de los campos, para no tener que mirarla en el fichero director

#IDENTIFICACIÓN DE LA VIVIENDA-----------------------------------------------------------------------------------------------------------

# PERIODO -> Periodo de recogida de la vivienda (formato -> aaaan; año + n-trimestre)
# TAMANO -> Tamaño del municipio (índice por habitantes -> valores en doc director)
# IDQ_PV -> Provincia (índices por porvincia -> valores en doc director)
# CA -> Comunidad autonoma (IDEM provincia)
# FACCAL -> Factor de elevación calibrado (formato numerico -> nnnnnn.nnnnnn)

#CARACTERÍSTICAS DE LA VIVIENDA----------------------------------------------------------------------------------------------------------

# REGVI -> Régimen de tenencia, es decir alquilada,, hipoteca, etc (índices por tipo -> valores en doc director)
# COCINA -> Disponibilidad de cocina (1 -> Sí ; 6 -> No)
# NHABVI -> Número de habitaciones
# METROSVI -> Metros cuadrados útiles en la vivienda

#CARACTERÍSTICAS DEL EDIFICIO------------------------------------------------------------------------------------------------------------

# TIPOVIV -> Tipo de edificio  (índices 1-6 -> valores en doc director)
# ANEDI -> Año de construcción (índices 1-9 -> valores en doc director)
# ANOANEDI -> Año de cosntrucción (solo valores del 20021 al 2020)
# FEDI -> Fecha de construcción (índices 01 - 11 -> valores en doc director)

#CARACTERÍSTICAS DEL HOGAR---------------------------------------------------------------------------------------------------------------

# TIP0HO -> Tipo de hogar (índices 1-16 -> valores en doc director)


```


```{r}
#librerias
library(readr)
library(readxl)
library(dplyr)
library(tidyr)
library(lubridate)
library(caret)
```


```{r}
hogar <- read.csv("./data/datos_hogares_2020/ECHHogares_2020.csv", sep = "\t")
persona <- read.csv("./data/datos_personas_2020/ECHPersonas_2020.csv", sep = "\t")
```

Tenemos un diccionario para leer los datos, lo vamos a intentar usar para leer los datos con el formato deseado:
```{r variables de hogar a caracter}
dic <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", skip = 1)

tab1 <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = "Tablas1", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab1) <- c("Cod", "Desc", "Var")
ind <- which(tab1$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab1[(ind[i]-1):nrow(tab1), "Var"] <- tab1[ind[i]-1, 3]
    tab1[(ind[i]-1):nrow(tab1), "New_Var"] <- tab1[ind[i]-1, 1]
  } else {
    tab1[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab1[ind[i]-1, 3]
    tab1[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab1[ind[i]-1, 1]
  }
}
I <- (!is.na(tab1$Cod != "Código") & tab1$Cod != "Código")
tab1 <- tab1[I, ]

J <- (!is.na(tab1$Desc))
tab1 <- tab1[J, ]

tab2 <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = "Tablas2", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab2) <- c("Cod", "Desc", "Var")
ind <- which(tab2$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab2[(ind[i]-1):nrow(tab2), "Var"] <- tab2[ind[i]-1, 3]
    tab2[(ind[i]-1):nrow(tab2), "New_Var"] <- tab2[ind[i]-1, 1]
  } else {
    tab2[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab2[ind[i]-1, 3]
    tab2[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab2[ind[i]-1, 1]
  }
}
I <- (!is.na(tab2$Cod != "Código") & tab2$Cod != "Código")
tab2 <- tab2[I, ]

J <- (!is.na(tab2$Desc))
tab2 <- tab2[J, ]
tab2_2 <- tab2[tab2$Var %in% c("TIPOHO"),]


tab <- full_join(tab1, tab2_2)

tab$Cod <- as.numeric(as.character(tab$Cod))

for (i in names(hogar)){
  #el vector pos es el que contiene las posiciones de tab que contienen info sobre esa variable
  pos <- which(tab$Var == i)
  #el if es porque hay variables que no están en la tabla
  if (length(pos)>0){
    #ahora tenemos que sustituir el código por lo que toca
    for (j in seq(1, length(pos))){
      #el vector cod contiene las posiciones de hogar que tienen el mismo código para así poder sustituirlos
      cod <- which(hogar[,i] == tab$Cod[pos[j]])
      hogar[cod, i] <- tab$Desc[pos[j]]
    }
  }
}

```

```{r df personas}
dic_personas <- read_excel("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", skip = 1)

tab1_personas <- read_excel("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = "Tablas1", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab1_personas) <- c("Cod", "Desc", "Var")
ind <- which(tab1_personas$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab1_personas[(ind[i]-1):nrow(tab1_personas), "Var"] <- tab1_personas[ind[i]-1, 3]
    tab1_personas[(ind[i]-1):nrow(tab1_personas), "New_Var"] <- tab1_personas[ind[i]-1, 1]
  } else {
    tab1_personas[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab1_personas[ind[i]-1, 3]
    tab1_personas[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab1_personas[ind[i]-1, 1]
  }
}
I <- (!is.na(tab1_personas$Cod != "Código") & tab1_personas$Cod != "Código")
tab1_personas <- tab1_personas[I, ]

J <- (!is.na(tab1_personas$Desc))
tab1_personas <- tab1_personas[J, ]

tab2_personas <- read_excel("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = "Tablas2", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab2_personas) <- c("Cod", "Desc", "Var")
ind <- which(tab2_personas$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab2_personas[(ind[i]-1):nrow(tab2_personas), "Var"] <- tab2_personas[ind[i]-1, 3]
    tab2_personas[(ind[i]-1):nrow(tab2_personas), "New_Var"] <- tab2_personas[ind[i]-1, 1]
  } else {
    tab2_personas[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab2_personas[ind[i]-1, 3]
    tab2_personas[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab2_personas[ind[i]-1, 1]
  }
}
I <- (!is.na(tab2_personas$Cod != "Código") & tab2_personas$Cod != "Código")
tab2_personas <- tab2_personas[I, ]

J <- (!is.na(tab2_personas$Desc))
tab2_personas <- tab2_personas[J, ]

#Hay variables que como "NACIM *** (2 veces más)", no detectan correctamente las variables, he tenido que hacer este sistema para arreglarlo

tab2_personas[tab2_personas == "NACIM *** (2 veces más)"] <- "NACIM"

tab2_personas_2_3 <- tab2_personas[19:20,]
variables_NACIM <- c("NACIM","NACIMPADRE","NACIMMADRE")
tab2_personas_2_3 <- do.call(rbind, replicate(3, tab2_personas_2_3, simplify = FALSE))
tab2_personas_2_3$Var[which(tab2_personas_2_3[,"Desc"] == "España")] <-  variables_NACIM

ind <- which(tab2_personas_2_3[,"Desc"] == "España")

for (i in (1:length(ind))){
  if (i + 1 <= length(ind)){
  tab2_personas_2_3$Var[ind[i]:(ind[i+1] - 1)] <- variables_NACIM[i]
}
  else{
  tab2_personas_2_3$Var[ind[i]:nrow(tab2_personas_2_3)] <- variables_NACIM[i]  
  }
}

tab2_personas[tab2_personas == "P01 *** (18 veces más)"] <- "P01"

tab2_personas_2 <- tab2_personas[26:33,]
vector_p <- paste0("P", sprintf("%02d", seq(1, 19)))
tab2_personas_2 <- do.call(rbind, replicate(19, tab2_personas_2, simplify = FALSE))
tab2_personas_2$Var[which(tab2_personas_2[,"Desc"] == "Padre/Madre")] <-  vector_p

ind <- which(tab2_personas_2[,"Desc"] == "Padre/Madre")

for (i in (1:length(ind))){
  if (i + 1 <= length(ind)){
  tab2_personas_2$Var[ind[i]:(ind[i+1] - 1)] <- vector_p[i]
}
  else{
  tab2_personas_2$Var[ind[i]:nrow(tab2_personas_2)] <- vector_p[i]  
  }
}

tab2_personas_ok <- full_join(tab2_personas,tab2_personas_2)
tab2_personas_ok_ok <- full_join(tab2_personas_ok,tab2_personas_2_3)

tab3_personas <- read_excel("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = "Tablas3", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab3_personas) <- c("Cod", "Desc", "Var")
ind <- which(tab3_personas$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab3_personas[(ind[i]-1):nrow(tab3_personas), "Var"] <- tab3_personas[ind[i]-1, 3]
    tab3_personas[(ind[i]-1):nrow(tab3_personas), "New_Var"] <- tab3_personas[ind[i]-1, 1]
  } else {
    tab3_personas[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab3_personas[ind[i]-1, 3]
    tab3_personas[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab3_personas[ind[i]-1, 1]
  }
}
I <- (!is.na(tab3_personas$Cod != "Código") & tab3_personas$Cod != "Código")
tab3_personas <- tab3_personas[I, ]

J <- (!is.na(tab3_personas$Desc))
tab3_personas <- tab3_personas[J, ]

variables <- c("PNACIMT","PNACT","PNACNACIMT","PNACIMPADRET","PNACIMMADRET")

tab3_personas[tab3_personas == "PNACIMT *** (4 veces más)"] <- "PNACIMT"
which(tab3_personas[,"Desc"] == "Austria")
tab3_personas <- rbind(tab3_personas, tab3_personas, tab3_personas, tab3_personas, tab3_personas)
tab3_personas$Var[which(tab3_personas[,"Desc"] == "Austria")] <-  variables
ind <- which(tab3_personas[,"Desc"] == "Austria")

for (i in (1:length(ind))){
  if (i + 1 <= length(ind)){
  tab3_personas$Var[ind[i]:(ind[i+1] - 1)] <- variables[i]
}
  else{
  tab3_personas$Var[ind[i]:nrow(tab3_personas)] <- variables[i]  
  }
}

tab_personas <- full_join(tab1_personas, tab2_personas_ok_ok)
tab_personas_ok <- full_join(tab_personas, tab3_personas)
tab_personas_ok_2 <- tab_personas_ok[tab_personas_ok$Var %in% c("CA", "IDQ_PV","P01","RELACT","SITUHO","SITUHO_D", "PNACIMT","PNACT","PNACNACIMT","PNACNACIMPADRET","PNACNACIMMADRET","PNACNACIMT","PNACIMPADRET","PNACIMMADRET"),]
tab_personas_ok_2$Cod <- as.numeric(as.character(tab_personas_ok_2$Cod))

for (i in names(persona)){
  #el vector pos es el que contiene las posiciones de tab que contienen info sobre esa variable
  pos <- which(tab_personas_ok_2$Var == i)
  #el if es porque hay variables que no están en la tabla
  if (length(pos)>0){
    #ahora tenemos que sustituir el código por lo que toca
    for (j in seq(1, length(pos))){
      #el vector cod contiene las posiciones de hogar que tienen el mismo código para así poder sustituirlos
      cod <- which(persona[,i] == tab_personas_ok_2$Cod[pos[j]])
      persona[cod, i] <- tab_personas_ok_2$Desc[pos[j]]
    }
  }
}

```

```{r}
df <- full_join(hogar,persona)
rm(list=setdiff(ls(), "df"))
```


### Análisis de NA's

El dataset contiene numerosos NA's, esto se puede deber a diversos factores como valores perdidos o a que no procede establecer ningún valor en ese caso. Este dataset contiene mayoritariamente NA's debido a que muchos de los valores no tendrián ningun sentido si hubiesen sido rellenados con cualquiera de las categorías que el INE presenta. Por tanto voy a ir analizando el porque de los NA en cada caso.

```{r}
NA_analisis <- sapply(df, function(x) {mean(is.na(x)) * 100
})
NA_analisis 
```

Hay variables con un 100% de NA y otras con porcentajes del 50%, 60%, 45%, 16% etc, la cuestión es que una gran cantidad de variables presentan NA's, sin embargo hay una serie de patrones que pueden ayudar a identificar las causas.

```{r}
vector_p <- paste0("P", sprintf("%02d", seq(1, 19)))
NA_analisis_P <- sapply(df[,vector_p], function(x) {mean(is.na(x)) * 100
})
NA_analisis_P
```

Las primeras variables que analizaré son P01:P19, estas indican las relaciones de parentesco entre los miembros del hogar, P01, permite recoger todas las relaciones con respecto al miembro encuestado y el resto de variables no reccogen más información que la relación entre el resto de miembros de la unidad familiar, información que ya se puede conocer con P01 aunque sea de forma implicita, por tanto no nos aportan más información y se podrían eliminar.Además podemos establecer como valor al miembro encuestrado para evitar un NA.

```{r}
df[ ,"P01"][which(df[,"NPV"] == 1)] <- "Miembro encuestado"


df <- df %>% 
  select(-(P02:P19))

NA_analisis_P <- mean(is.na(df[,"P01"]) * 100)
NA_analisis_P

```

A continuación se estudian las variables SEXOPAR, NACPAR, ECPAR, HIJOSDEAMBOS, se van a estudiar juntas porque viendo el porcentaje de NA's coincide en los cuatro casos de un 50.236605%, esto también sucede para las variables NHIJO_NUCLEO, NHIJOME_NUCLEO y SITNUCLEOFAM con un 44.979064%, ESTUDIOS y RELACT con un 14.990599% y NHIJO, NHIJOMENOR y NUCLEOFAM con un 16.580078%.

```{r}
df_EC <- df %>% 
  select(EC,ECPAR,NACPAR,SEXOPAR,HIJOSDEAMBOS,ID_VIV) %>% 
  filter(EC == 2)

df_EC_alt <- df %>% 
  select(EC,ECPAR,NACPAR,SEXOPAR,HIJOSDEAMBOS,ID_VIV) %>% 
  filter(!(EC == 2)) 

  sapply(df_EC, function(x) {sum(is.na(x)) 
})
    sapply(df_EC_alt, function(x) {mean(is.na(x)) 
})

df <- df %>%
  filter(!(EC == 2 & is.na(ECPAR)))

```

Cuando establecemos EC == casados al ser pareja, deberían de aparecer los registros sobre su pareja(ECPAR, NACPAR, SEXOPAR) y HIJOSDEAMBOS, tengan o no tengan, sin embargo en el 3.38% de los casos no es así, posiblemente sea porque son datos perdidos.

Cuando son solteros, divorciados, viudos o separados pueden vivir o no con una pareja entonces es lógico que aparezcan datos ausentes, una opción sería rellenar con NO procede los datos ausentes previo a realizar el codificado.

```{r}
df_EC_2 <- df %>% 
select(EC,NHIJOME_NUCLEO,NHIJO_NUCLEO,SITUNUCLEOFAM,ID_VIV) %>% 
  filter(EC == 2)

  sapply(df_EC_2, function(x) {mean(is.na(x)) 
})
```

Al haber eliminado anteriormente las filas de personas casadas sin datos en las categorias anteriores, tampoco aparecen datos ausentes para los casados, para los no casados si hay NA lo cual es lógico pues no procede si una persona no casado no tiene hijos o no pertenece a ninguna de las categorias de SITUNUCLEOFAM, por tanto hacemos como anteriormente.

```{r}
df_EDAD <- df %>% 
select(ESTUDIOS,RELACT,EDAD) %>% 
  filter(EDAD >= 16)

  sapply(df_EDAD, function(x) {mean(is.na(x)) 
})
  
  df <- df %>%
  mutate(
    RELACT = ifelse(is.na(RELACT), "No procede", RELACT)
  )
```

Los menores de 16 años no quedan registrados con ningún tipo de estudios ni relación laboral ni tampoco ocupación, por tanto son NA que se explican por ese motivo.

```{r}
df_extranjeros <- df %>% 
  select(EDADFLLEG,TPOFLLEG,NACIM,TPOFNACESP,NAC) %>% 
  filter(NACIM != 1 & NAC == 1)

  sapply(df_extranjeros, function(x) {mean(is.na(x))
})
  
    
df_NACIONALIDAD <- df %>% 
select(NACNACIMESP,NAC) %>% 
  filter(!(NAC == 3))

  sapply(df_NACIONALIDAD, function(x) {mean(is.na(x)) 
})
```

Las variables EDADFLLEG y TPOFLLEG miden la edad con la que un extranjero llego a españa y el tiempo que lleva residiendo respectivamente mientras que TPOFNACESP es el tiempo que lleva alguien con la nacionalidad española adquirida, cuando filtramos por no nacionales españoles y gente con nacionalidad española, vemos que desaparecen los NA lo cual es lógico puesto que un ciudadano español nacido en españa ya reside en españa desde que nació y por otro lado, todo ciudadano que no haya querido solicitar la nacionalidad española no le procede contestar cuanto años hace que la adquirio.

Finalmente NACNACIMESP mide si alguien tiene o no la nacionalidad española de nacimiento o la adquirio después, si no la han solicitado no procede contestar y por eso aparecen los NA.

```{r}
df_OCUPADOS <- df %>% 
  select(OCUPA,RELACT) %>% 
  filter((RELACT == "Trabajando a tiempo completo" | RELACT == "Trabajando a tiempo parcial"))

  sapply(df_OCUPADOS, function(x) {mean(is.na(x)) 
})
  
df_CONSTRUCCION <- df %>% 
  select(ANOANEDI,ANEDI) %>% 
  filter(ANEDI == 1)

  sapply(df_CONSTRUCCION, function(x) {mean(is.na(x)) 
})
  
table(df$FEDI,df$ANEDI)

df <- df %>% 
  select(-ANOANEDI & -ANEDI)

```

Que haya muchos NA es comprensible en el apartado de OCUPA puesto que si el entrevistado no se encuentra ocupado no puede contestar nada, respecto a ANONEDI solo recoge datos de construcción de vivienda a partir de los años 2000, por lo que no aporta información adicional relevante respecto a las variables ANEDI y FEDI, de hecho, ANEDI tampoco aporta más información que la variable FEDI, por lo que estas dos variables se pueden suprimir.

```{r}
NA_analisis <- sapply(df, function(x) {mean(is.na(x)) * 100
})
NA_analisis

```

Con esto hemos eliminado todos los valores ausentes del conjunto de datos, faltaría codificar todos los cambios realizados de forma que no afecte luego en fases posteriores del analisis.

### Cambios de tipo de variables

La variable periodo representa una variable de tipo fecha Año-Trimestre, aunque ahora aparece como una variable de tipo numérico. Por otro lado hemos estado trabajando con una gran cantidad de variables de tipo factor que actualmente aparecen como de tipo caracter y deben ser cambiadas, en la fase de codificación se pasarán a númerico para poder usados en análisis de correlación, modelos de regresión etc.

```{r}
rm(list=setdiff(ls(), "df"))
df$PERIODO <- gsub("^(.{4})(.{0,})", "\\10\\2", df$PERIODO)

columnas_int_factor <- c("TAMANO","REGVI","TIPOVIV","FEDI","NACHO","SEXO","EC","NACIM","COCINA","NAC","NACNACIMESP","NACIMPADRE","NACIMMADRE","OCUPA","PAREJA","SEXOPAR","NACPAR","ECPAR","HIJOSDEAMBOS","ESTUDIOS","FEDI")

df <- df |> 
  mutate(PERIODO = yq(PERIODO)) |>  
  mutate_if(is.character, factor) |> 
  mutate_at(vars(columnas_int_factor), as.factor)

str(df)
```

Analizando los levels de las variables factor nos encontramos con países con código "966" y "555", que no aparecen en los diccionarios proporcionados en el INE y que por tanto se han debido de tratar de errores de escritura, por tanto vamos a filtrarlos.

```{r}
df <- df %>% 
  filter(PNACIMT != "966" & PNACT != "555" & PNACIMPADRET != "966" & PNACIMMADRET != "966") %>% 
  droplevels()

str(df)
```

### Cambio nombre variables

Cambios de nombre de variables para mejorar la claridad de algunas variables

```{r}
df <- df %>% 
  rename(
    PROVINCIA = IDQ_PV,
    F_CONS_EDI = FEDI,
    PERS_HOGAR = TAMTOHO,
    NAC_HO = NACHO,
    PAIS_NACIM = PNACIMT,
    EDAD_LLEG_ESP = EDADFLLEG,
    TPO_LLEG_ESP =TPOFLLEG,
    PAIS_NAC = PNACT,
    PAIS_NAC_NACIM = PNACNACIMT,
    TPO_NAC_ESP = TPOFNACESP,
    PAIS_NACIM_PADRE = PNACIMPADRET,
    PAIS_NACIM_MADRE = PNACIMMADRET,
    RELAC_MIEMBROS = P01,
    ACTIVIDAD = RELACT,
)
```


### Recodificación de variables

En un inicio nuestro dataset presentaba un tipo de codificación ya establecido, el problema era la dificultad de interpretar el dataset y sus posibles relaciones entonces se decidió descodificar primero las variables para poder entender que significaba cada cosa de forma sencilla. Tras haber realizado una parte del proceso de limpieza del dataset, es necesario recodificarlo, esta vez acorde al tipo de codificación que queramos a la hora de poder hacer un buen análisis de detección de outliers y busqueda de correlaciones entre variables.

Las variables a codificar son aquellas de tipo categórico. Las variables categóricas se dividen en dos grupos: ordinales y cardinales. En las variables categóricas ordinales, las variables se pueden codificar acorde a un orden númerico ya que existe una jerarquia. a > b > c, en las variables cardinales por el contrario, no se aprecia un orden entre las variables: Andalucia !> Aragón. Esto es importante porque para cada caso las técnicas de codificación son distintas.

Como variables ordinales en este caso podemos considerar a TAMAÑO, ESTUDIOS, TIPOVIV, FEDI, mientras que el resto son cardinales.

```{r}
categoricas_ordinales <- c("TAMANO","TIPOVIV","F_CONS_EDI","ESTUDIOS")

df[, categoricas_ordinales] <- sapply(df[, categoricas_ordinales], function(x) as.numeric(factor(x)))

str(df)
```

```{r}
columnas_dummy <- c("REGVI","NAC_HO","SEXO","EC","NACIM","COCINA","NAC","NACNACIMESP","NACIMPADRE","NACIMMADRE","OCUPA","PAREJA","SEXOPAR","NACPAR","ECPAR","HIJOSDEAMBOS")


# Create dummy variables
dummy <- dummyVars(paste("~", paste(columnas_dummy,collapse = " + ")), data = df)

# Apply the dummy variables to the dataframe
df_dummies <- data.frame(predict(dummy, newdata = df))

df_merged <- cbind(df, df_dummies)

df_merged <- df_merged %>% 
  select(!(columnas_dummy))

columnas_int_factor <- c("TAMANO","REGVI","TIPOVIV","NAC_HO","SEXO","EC","NACIM","COCINA","NAC","NACNACIMESP","NACIMPADRE","NACIMMADRE","OCUPA","PAREJA","SEXOPAR","NACPAR","ECPAR","HIJOSDEAMBOS","ESTUDIOS","F_CONS_EDI")

df <- df |> 
  mutate_at(vars(columnas_int_factor), as.integer)

str(df_merged)
str(df)
```

### Normalizar las variables númericas


```{r}

df_norm <- df_merged |> 
  select(is.numeric | is.integer) |> 
  select(-c(ID_VIV,FACCAL)) |> 
  mutate(across(1:25, ~scale(.)))

```


### Casos posibles a estudiar

1. El tamaño de la provincia afecta a las carácteristicas del hogar?

2. Afecta tu nivel de estudios en donde vives?

3. Tu estado civil tiene relación con tu hogar?

4. Existen diferencias entre nacionales y extranjeros en nivel de estudios, ocupación, hijos, tamaño de población o tipo de vivienda?

5. Esta correlacionada la edad con tu vivienda?

6. Existe alguna diferencia entre los extranjeros nacionalizados y los no nacionalizados?


```{r}
df_merged_1 <- df %>% 
  select(c(TAMANO,PROVINCIA,CA,ASEOS,COMEDORES,TRASTEROS,OTRASHAB,HABVI,METROSVI,TIPOVIV,F_CONS_EDI,REGVI,NPV)) %>% 
  filter(NPV == 1) %>% 
  select(!c(CA,PROVINCIA,NPV))

df_norm <- df_norm %>% 
  select(!c(PROVINCIA,CA))

cor(df_merged_1,method = "pearson")

```

### Detección de outliers

```{r}
deteccion_outliers <- function(data){

n<-length(data)
nMiss<-sum(is.na(data)==TRUE)

# p5-p95
lowLim<-quantile(data,0.05)
upLim<-quantile(data,0.95)
minNom<-min(data[which(data>lowLim)])
maxNom<-max(data[which(data<upLim)])
nOut<-length(which(data<lowLim | data>upLim))


# 3signa
umbral3s<-mean(data)+3*sd(data)

nOut3s<-length(data[abs(data)>umbral3s])
lowLim3s<-mean(data)-3*sd(data)
upLim3s<-mean(data)+3*sd(data)
minNom<-min(data[(which(data>=lowLim3s))])
maxNom<-max(data[(which(data<=upLim3s))])

outliers<-data.frame(method='tresSigma', n=n, nMiss=nMiss, nOut=nOut3s, lowLim=lowLim3s,upLim=upLim3s,minNom=minNom,maxNom=maxNom)

# Hampel

MADM<-1.4826*median(abs(data-median(data))) # Se puede calcular como mad(data)
umbral3s<-median(data)+3*MADM
nOut3s<-length(data[abs(data)>umbral3s])
lowLim3s<-median(data)-3*MADM
upLim3s<-median(data)+3*MADM
minNom<-min(data[(which(data>=lowLim3s))])
maxNom<-max(data[(which(data<=upLim3s))])
outliers<-rbind(outliers,data.frame(method='Hampel', n=n, nMiss=nMiss, nOut=nOut3s, lowLim=lowLim3s,upLim=upLim3s,minNom=minNom,maxNom=maxNom)
)

# Boxplot

Q3Q1<-IQR(data)
Q3<-quantile(data,probs = 0.75)%>%as.numeric
Q1<-quantile(data,probs = 0.25)%>%as.numeric
umbralSup<-Q3+1.5*Q3Q1
umbralInf<-Q1-1.5*Q3Q1

nOut3s<-length(data[data>umbralSup |data<umbralInf])
lowLim3s<-umbralInf
upLim3s<-umbralSup
minNom<-min(data[(which(data>=lowLim3s))])
maxNom<-max(data[(which(data<=upLim3s))])
outliers<-rbind(outliers,data.frame(method='ReglaBoxplot', n=n, nMiss=nMiss, nOut=nOut3s, lowLim=lowLim3s,upLim=upLim3s,minNom=minNom,maxNom=maxNom))

return(outliers)

}

deteccion_outliers(df_merged_1$HABVI)

```

