---
title: "Pruebas ProyectoAED2023"
output: html_document
date: "2023-10-12"
---

```{r}
library(readr)
library(readxl)
```

```{r}
hogar <- read.csv("./data/datos_hogares_2020/ECHHogares_2020.csv", sep = "\t")
persona <- read.csv("./data/datos_personas_2020/ECHPersonas_2020.csv", sep = "\t")
dic_hogar <- read_xlsx("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", skip = 1)
dic_hogar_t1 <- read_xlsx("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = 2)
dic_hogar_t2 <- read_xlsx("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = 3)
dic_persona <- read_xlsx("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", skip = 1)
dic_persona_t1 <- read_xlsx("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = 2)
dic_persona_t2 <- read_xlsx("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = 3)
dic_persona_t3 <- read_xlsx("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = 4)
```

El siguiente bloque de código se encarga de reemplazar todos los términos con un diccionario asociado. Tarda bastante en ejecutarse, supongo que por la cantidad de filas y columnas y la longitud de lo que tiene que reemplazar. Lo dejo para todas las columnas, pero se puede especificar para que actúe sobre las que queramos.

```{r}
for (i in seq_len(nrow(dic_hogar))) {
  if (!is.na(dic_hogar$`Diccionario ubicado en la hoja…`[i])){
    
    # If the variable has a dictionary, print the name of the sheet where it is located
    
    cat(sprintf("Variable %s has dictionary located in sheet %s\n", dic_hogar$Variable[i], dic_hogar$`Diccionario ubicado en la hoja…`[i]))
    
    if(dic_hogar$`Diccionario ubicado en la hoja…`[i] == "Tablas1"){
      consult <- dic_hogar_t1
      # Find the row index where the word is found
      start_row <- which(consult$`En hoja -Diseño-. Variables:` == dic_hogar$Variable[i])
      # Find the row index where NA is found after the word
      for(fila in start_row:length(consult[[1]])){
        if(is.na(consult[[1]][fila]) == T){
          end_row <- fila
          break
        }else {
          end_row <- fila
        }
      }
      
      # Select the subset of rows between the word and the first NA
      subset_df <- consult[start_row:end_row, ]
      subset_df[[1]] <- as.numeric(subset_df[[1]])
      
      for(j in 1:length(hogar[[dic_hogar$Variable[i]]])){
       if (is.na(hogar[[dic_hogar$Variable[i]]][j]) == T){
          next
        }else{
        hogar[[dic_hogar$Variable[i]]][j] <- subset_df[[2]][which(subset_df[1] == hogar[[dic_hogar$Variable[i]]][j])]
        }
      }
    
    
   }else if(dic_hogar$`Diccionario ubicado en la hoja…`[i] == "Tablas2"){
    
      consult <- dic_hogar_t2
      # Find the row index where the word is found
      start_row <- which(consult$`En hoja -Diseño-. Variables:` == dic_hogar$Variable[i])
      # Find the row index where NA is found after the word
      for(fila in start_row:length(consult[[1]])){
        if(is.na(consult[[1]][fila]) == T){
          end_row <- fila
          break
        }else {
          end_row <- fila
        }
      }
      
      # Select the subset of rows between the word and the first NA
      subset_df <- consult[start_row:end_row, ]
      subset_df[[1]] <- as.numeric(subset_df[[1]])
      
      for(j in 1:length(hogar[[dic_hogar$Variable[i]]])){
        if (is.na(hogar[[dic_hogar$Variable[i]]][j]) == T){
          next
        }else{
        hogar[[dic_hogar$Variable[i]]][j] <- subset_df[[2]][which(subset_df[1] == hogar[[dic_hogar$Variable[i]]][j])]
        }
      }
      
   }else {
    # If the variable does not have a dictionary, print a message indicating so
    cat(sprintf("Variable %s does not have a dictionary\n", dic_hogar$Variable[i]))
  }
 }
}
```

Vamos a tratar de realizar un primer análisis exploratorio del DataSet **hogar**. Para ello, en primer lugar observaremos las columnas del DataSet y el tipo de elementos que contienen

```{r}
str(hogar)
```
Además de un alista con las distintas columnas y sus tipos de datos, podemos generar un resumen con distintos estadísticos para cada una de las variables

```{r}
summary(hogar)
```
Esta función también nos permite observar qué columnas contienen NA's, información que nos será útil a futuro de cara a limpiar nuestro DataSet o trabajar con los datos

Como podemos observar, hay muchas columnas que contienen índices que no reflejan la información como tal, si no que hacen referencia a una escala externa, presente en otro documento. Además, hay ciertos nombres de variable que no son del todo claros, los cambiaremos para que sean más representativos. Lo que haremos a continuación será obtener la información real


```{r}
# En este chunK de código voy a poner, comentado para saber que hay que modificarlo o borrarlo, info relevante acerca de los campos, para no tener que mirarla en el fichero director

#IDENTIFICACIÓN DE LA VIVIENDA-----------------------------------------------------------------------------------------------------------

# PERIODO -> Periodo de recogida de la vivienda (formato -> aaaan; año + n-trimestre)
# TAMANO -> Tamaño del municipio (índice por habitantes -> valores en doc director)
# IDQ_PV -> Provincia (índices por porvincia -> valores en doc director)
# CA -> Comunidad autonoma (IDEM provincia)
# FACCAL -> Factor de elevación calibrado (formato numerico -> nnnnnn.nnnnnn)

#CARACTERÍSTICAS DE LA VIVIENDA----------------------------------------------------------------------------------------------------------

# REGVI -> Régimen de tenencia, es decir alquilada,, hipoteca, etc (índices por tipo -> valores en doc director)
# COCINA -> Disponibilidad de cocina (1 -> Sí ; 6 -> No)
# NHABVI -> Número de habitaciones
# METROSVI -> Metros cuadrados útiles en la vivienda

#CARACTERÍSTICAS DEL EDIFICIO------------------------------------------------------------------------------------------------------------

# TIPOVIV -> Tipo de edificio  (índices 1-6 -> valores en doc director)
# ANEDI -> Año de construcción (índices 1-9 -> valores en doc director)
# ANOANEDI -> Año de cosntrucción (solo valores del 20021 al 2020)
# FEDI -> Fecha de construcción (índices 01 - 11 -> valores en doc director)

#CARACTERÍSTICAS DEL HOGAR---------------------------------------------------------------------------------------------------------------

# TIP0HO -> Tipo de hogar (índices 1-16 -> valores en doc director)


```


```{r}
#librerias
library(readr)
library(readxl)
library(dplyr)
library(tidyr)
library(lubridate)
```


```{r}
hogar <- read.csv("./data/datos_hogares_2020/ECHHogares_2020.csv", sep = "\t")
persona <- read.csv("./data/datos_personas_2020/ECHPersonas_2020.csv", sep = "\t")
```

Tenemos un diccionario para leer los datos, lo vamos a intentar usar para leer los datos con el formato deseado:
```{r variables de hogar a caracter}
dic <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", skip = 1)

tab1 <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = "Tablas1", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab1) <- c("Cod", "Desc", "Var")
ind <- which(tab1$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab1[(ind[i]-1):nrow(tab1), "Var"] <- tab1[ind[i]-1, 3]
    tab1[(ind[i]-1):nrow(tab1), "New_Var"] <- tab1[ind[i]-1, 1]
  } else {
    tab1[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab1[ind[i]-1, 3]
    tab1[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab1[ind[i]-1, 1]
  }
}
I <- (!is.na(tab1$Cod != "Código") & tab1$Cod != "Código")
tab1 <- tab1[I, ]

J <- (!is.na(tab1$Desc))
tab1 <- tab1[J, ]

tab2 <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = "Tablas2", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab2) <- c("Cod", "Desc", "Var")
ind <- which(tab2$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab2[(ind[i]-1):nrow(tab2), "Var"] <- tab2[ind[i]-1, 3]
    tab2[(ind[i]-1):nrow(tab2), "New_Var"] <- tab2[ind[i]-1, 1]
  } else {
    tab2[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab2[ind[i]-1, 3]
    tab2[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab2[ind[i]-1, 1]
  }
}
I <- (!is.na(tab2$Cod != "Código") & tab2$Cod != "Código")
tab2 <- tab2[I, ]

J <- (!is.na(tab2$Desc))
tab2 <- tab2[J, ]
tab2_2 <- tab2[tab2$Var %in% c("TIPOHO"),]


tab <- full_join(tab1, tab2_2)

tab$Cod <- as.numeric(as.character(tab$Cod))

for (i in names(hogar)){
  #el vector pos es el que contiene las posiciones de tab que contienen info sobre esa variable
  pos <- which(tab$Var == i)
  #el if es porque hay variables que no están en la tabla
  if (length(pos)>0){
    #ahora tenemos que sustituir el código por lo que toca
    for (j in seq(1, length(pos))){
      #el vector cod contiene las posiciones de hogar que tienen el mismo código para así poder sustituirlos
      cod <- which(hogar[,i] == tab$Cod[pos[j]])
      hogar[cod, i] <- tab$Desc[pos[j]]
    }
  }
}

```

```{r df personas}
dic_personas <- read_excel("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", skip = 1)

tab1_personas <- read_excel("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = "Tablas1", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab1_personas) <- c("Cod", "Desc", "Var")
ind <- which(tab1_personas$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab1_personas[(ind[i]-1):nrow(tab1_personas), "Var"] <- tab1_personas[ind[i]-1, 3]
    tab1_personas[(ind[i]-1):nrow(tab1_personas), "New_Var"] <- tab1_personas[ind[i]-1, 1]
  } else {
    tab1_personas[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab1_personas[ind[i]-1, 3]
    tab1_personas[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab1_personas[ind[i]-1, 1]
  }
}
I <- (!is.na(tab1_personas$Cod != "Código") & tab1_personas$Cod != "Código")
tab1_personas <- tab1_personas[I, ]

J <- (!is.na(tab1_personas$Desc))
tab1_personas <- tab1_personas[J, ]

tab2_personas <- read_excel("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = "Tablas2", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab2_personas) <- c("Cod", "Desc", "Var")
ind <- which(tab2_personas$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab2_personas[(ind[i]-1):nrow(tab2_personas), "Var"] <- tab2_personas[ind[i]-1, 3]
    tab2_personas[(ind[i]-1):nrow(tab2_personas), "New_Var"] <- tab2_personas[ind[i]-1, 1]
  } else {
    tab2_personas[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab2_personas[ind[i]-1, 3]
    tab2_personas[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab2_personas[ind[i]-1, 1]
  }
}
I <- (!is.na(tab2_personas$Cod != "Código") & tab2_personas$Cod != "Código")
tab2_personas <- tab2_personas[I, ]

J <- (!is.na(tab2_personas$Desc))
tab2_personas <- tab2_personas[J, ]

#Hay variables que como "NACIM *** (2 veces más)", no detectan correctamente las variables, he tenido que hacer este sistema para arreglarlo

tab2_personas[tab2_personas == "NACIM *** (2 veces más)"] <- "NACIM"

tab2_personas_2_3 <- tab2_personas[19:20,]
variables_NACIM <- c("NACIM","NACIMPADRE","NACIMMADRE")
tab2_personas_2_3 <- do.call(rbind, replicate(3, tab2_personas_2_3, simplify = FALSE))
tab2_personas_2_3$Var[which(tab2_personas_2_3[,"Desc"] == "España")] <-  variables_NACIM

ind <- which(tab2_personas_2_3[,"Desc"] == "España")

for (i in (1:length(ind))){
  if (i + 1 <= length(ind)){
  tab2_personas_2_3$Var[ind[i]:(ind[i+1] - 1)] <- variables_NACIM[i]
}
  else{
  tab2_personas_2_3$Var[ind[i]:nrow(tab2_personas_2_3)] <- variables_NACIM[i]  
  }
}

tab2_personas[tab2_personas == "P01 *** (18 veces más)"] <- "P01"

tab2_personas_2 <- tab2_personas[26:33,]
vector_p <- paste0("P", sprintf("%02d", seq(1, 19)))
tab2_personas_2 <- do.call(rbind, replicate(19, tab2_personas_2, simplify = FALSE))
tab2_personas_2$Var[which(tab2_personas_2[,"Desc"] == "Padre/Madre")] <-  vector_p

ind <- which(tab2_personas_2[,"Desc"] == "Padre/Madre")

for (i in (1:length(ind))){
  if (i + 1 <= length(ind)){
  tab2_personas_2$Var[ind[i]:(ind[i+1] - 1)] <- vector_p[i]
}
  else{
  tab2_personas_2$Var[ind[i]:nrow(tab2_personas_2)] <- vector_p[i]  
  }
}

tab2_personas_ok <- full_join(tab2_personas,tab2_personas_2)
tab2_personas_ok_ok <- full_join(tab2_personas_ok,tab2_personas_2_3)

tab3_personas <- read_excel("./data/datos_personas_2020/dr_ECHPersonas_2020.xlsx", sheet = "Tablas3", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab3_personas) <- c("Cod", "Desc", "Var")
ind <- which(tab3_personas$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab3_personas[(ind[i]-1):nrow(tab3_personas), "Var"] <- tab3_personas[ind[i]-1, 3]
    tab3_personas[(ind[i]-1):nrow(tab3_personas), "New_Var"] <- tab3_personas[ind[i]-1, 1]
  } else {
    tab3_personas[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab3_personas[ind[i]-1, 3]
    tab3_personas[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab3_personas[ind[i]-1, 1]
  }
}
I <- (!is.na(tab3_personas$Cod != "Código") & tab3_personas$Cod != "Código")
tab3_personas <- tab3_personas[I, ]

J <- (!is.na(tab3_personas$Desc))
tab3_personas <- tab3_personas[J, ]

variables <- c("PNACIMT","PNACT","PNACNACIMT","PNACIMPADRET","PNACIMMADRET")

tab3_personas[tab3_personas == "PNACIMT *** (4 veces más)"] <- "PNACIMT"
which(tab3_personas[,"Desc"] == "Austria")
tab3_personas <- rbind(tab3_personas, tab3_personas, tab3_personas, tab3_personas, tab3_personas)
tab3_personas$Var[which(tab3_personas[,"Desc"] == "Austria")] <-  variables
ind <- which(tab3_personas[,"Desc"] == "Austria")

for (i in (1:length(ind))){
  if (i + 1 <= length(ind)){
  tab3_personas$Var[ind[i]:(ind[i+1] - 1)] <- variables[i]
}
  else{
  tab3_personas$Var[ind[i]:nrow(tab3_personas)] <- variables[i]  
  }
}

tab_personas <- full_join(tab1_personas, tab2_personas_ok_ok)
tab_personas_ok <- full_join(tab_personas, tab3_personas)
tab_personas_ok_2 <- tab_personas_ok[tab_personas_ok$Var %in% c("CA", "IDQ_PV","P01","RELACT","SITUHO","SITUHO_D", "PNACIMT","PNACT","PNACNACIMT","PNACNACIMPADRET","PNACNACIMMADRET","PNACNACIMT","PNACIMPADRET","PNACIMMADRET"),]
tab_personas_ok_2$Cod <- as.numeric(as.character(tab_personas_ok_2$Cod))

for (i in names(persona)){
  #el vector pos es el que contiene las posiciones de tab que contienen info sobre esa variable
  pos <- which(tab_personas_ok_2$Var == i)
  #el if es porque hay variables que no están en la tabla
  if (length(pos)>0){
    #ahora tenemos que sustituir el código por lo que toca
    for (j in seq(1, length(pos))){
      #el vector cod contiene las posiciones de hogar que tienen el mismo código para así poder sustituirlos
      cod <- which(persona[,i] == tab_personas_ok_2$Cod[pos[j]])
      persona[cod, i] <- tab_personas_ok_2$Desc[pos[j]]
    }
  }
}

```

```{r}
df <- full_join(hogar,persona)
rm(list=setdiff(ls(), "df"))
```


### Análisis de NA's

El dataset contiene numerosos NA's, esto se puede deber a diversos factores como valores perdidos o a que no procede establecer ningún valor en ese caso. Este dataset contiene mayoritariamente NA's debido a que muchos de los valores no tendrián ningun sentido si hubiesen sido rellenados con cualquiera de las categorías que el INE presenta. Por tanto voy a ir analizando el porque de los NA en cada caso.

```{r}
NA_analisis <- sapply(df, function(x) {mean(is.na(x)) * 100
})
NA_analisis 
```

Hay variables con un 100% de NA y otras con porcentajes del 50%, 60%, 45%, 16% etc, la cuestión es que una gran cantidad de variables presentan NA's, sin embargo hay una serie de patrones que pueden ayudar a identificar las causas.

```{r}
vector_p <- paste0("P", sprintf("%02d", seq(1, 19)))
NA_analisis_P <- sapply(df[,vector_p], function(x) {mean(is.na(x)) * 100
})
NA_analisis_P
```

Las primeras variables que analizaré son P01:P19, estas indican las relaciones de parentesco entre los miembros del hogar, P01, permite recoger todas las relaciones con respecto al miembro encuestado y el resto de variables no reccogen más información que la relación entre el resto de miembros de la unidad familiar, información que ya se puede conocer con P01 aunque sea de forma implicita, por tanto no nos aportan más información y se podrían eliminar.Además podemos establecer como valor al miembro encuestrado para evitar un NA.

```{r}
df[ ,"P01"][which(df[,"NPV"] == 1)] <- "Miembro encuestado"


df <- df %>% 
  select(-(P02:P19))

NA_analisis_P <- mean(is.na(df[,"P01"]) * 100)

```

A continuación se estudian las variables SEXOPAR, NACPAR, ECPAR, HIJOSDEAMBOS, se van a estudiar juntas porque viendo el porcentaje de NA's coincide en los cuatro casos de un 50.236605%, esto también sucede para las variables NHIJO_NUCLEO, NHIJOME_NUCLEO y SITNUCLEOFAM con un 44.979064%, ESTUDIOS y RELACT con un 14.990599% y NHIJO, NHIJOMENOR y NUCLEOFAM con un 16.580078%.

```{r}
df_EC <- df %>% 
  select(EC,ECPAR,NACPAR,SEXOPAR,HIJOSDEAMBOS,ID_VIV) %>% 
  filter(EC == "Casado /a")

df_EC_alt <- df %>% 
  select(EC,ECPAR,NACPAR,SEXOPAR,HIJOSDEAMBOS,ID_VIV) %>% 
  filter(!(EC == "Casado /a")) 

  sapply(df_EC, function(x) {sum(is.na(x)) 
})
    sapply(df_EC_alt, function(x) {mean(is.na(x)) 
})

df <- df %>%
  filter(!(EC == 2 & is.na(ECPAR)))
    
  df <- df %>%
  mutate(
    ECPAR = ifelse(is.na(ECPAR), "No procede", ECPAR),
    NACPAR = ifelse(is.na(NACPAR), "No procede", NACPAR),
    SEXOPAR = ifelse(is.na(SEXOPAR), "No procede", SEXOPAR),
    HIJOSDEAMBOS = ifelse(is.na(HIJOSDEAMBOS), "No procede", HIJOSDEAMBOS)
  )
  

```

Cuando establecemos EC == casados al ser pareja, deberían de aparecer los registros sobre su pareja(ECPAR, NACPAR, SEXOPAR) y HIJOSDEAMBOS, tengan o no tengan, sin embargo en el 3.38% de los casos no es así, posiblemente sea porque son datos perdidos.

Cuando son solteros, divorciados, viudos o separados pueden vivir o no con una pareja entonces es lógico que aparezcan datos ausentes, una opción sería rellenar con NO procede los datos ausentes previo a realizar el codificado.

```{r}
df_EC_2 <- df %>% 
select(EC,NHIJOME_NUCLEO,NHIJO_NUCLEO,SITUNUCLEOFAM,ID_VIV) %>% 
  filter(EC == "Casado /a")

  sapply(df_EC_2, function(x) {mean(is.na(x)) 
})
  
   df <- df %>%
  mutate(
    NHIJOME_NUCLEO = ifelse(is.na(NHIJOME_NUCLEO), "No procede", NHIJOME_NUCLEO),
    NHIJO_NUCLEO = ifelse(is.na(NHIJO_NUCLEO), "No procede", NHIJO_NUCLEO),
    SITUNUCLEOFAM = ifelse(is.na(SITUNUCLEOFAM), "No procede", SITUNUCLEOFAM)
  )
  
```

Al haber eliminado anteriormente las filas de personas casadas sin datos en las categorias anteriores, tampoco aparecen datos ausentes para los casados, para los no casados si hay NA lo cual es lógico pues no procede si una persona no casado no tiene hijos o no pertenece a ninguna de las categorias de SITUNUCLEOFAM, por tanto hacemos como anteriormente.

```{r}
df_EDAD <- df %>% 
select(ESTUDIOS,RELACT,EDAD) %>% 
  filter(EDAD >= 16 )

  sapply(df_EDAD, function(x) {mean(is.na(x)) 
})
  
  df <- df %>%
  mutate(
    RELACT = ifelse(is.na(RELACT), "No procede", RELACT),
    ESTUDIOS = ifelse(is.na(ESTUDIOS), "No procede", ESTUDIOS)
  )
```

Los menores de 16 años no quedan registrados con ningún tipo de estudios ni relación laboral ni tampoco ocupación, por tanto son NA que se explican por ese motivo.

```{r}
table(df$NHIJO,df$NHIJO_NUCLEO)
table(df$NHIJOME_NUCLEO,df$NHIJOMENOR)
table(df$SITUNUCLEOFAM,df$NUCLEOFAM)

df_HIJOS <- df %>% 
  select(NHIJO_NUCLEO,NHIJOPAR,ID_VIV)



df <- df %>% 
  select(-NHIJO & -NHIJOMENOR & -NUCLEOFAM & -NHIJOPAR)

```

Las variables NHIJO, NHIJOMENOR y NUCLEOFAM, no recogen información adicional respecto a las variables NHIJO_NUCLEO, NHIJOME_NUCLEO y SITUNUCLEOFAM. Además de estas tres últimas tenemos todos los registros lógicos mientras que de las tres primeras variables tenemos valores ausentes que corresponderían con los valores de las variables NHIJO_NUCLEO, NHIJOME_NUCLEO y SITUNUCLEOFAM. Por tanto NHIJO, NHIJOMENOR y NUCLEOFAM se pueden eliminar. NHIJO_NUCLEO también engloba a NHIJOPAR entonces también se puede eliminar.

```{r}
df_extranjeros <- df %>% 
  select(EDADFLLEG,TPOFLLEG,NACIM,TPOFNACESP,NAC) %>% 
  filter(NACIM != "España" & NAC == "Española")

  sapply(df_extranjeros, function(x) {mean(is.na(x))
})
  
    
df_NACIONALIDAD <- df %>% 
select(NACNACIMESP,NAC) %>% 
  filter(!(NAC == "No tiene nacionalidad española"))

  sapply(df_NACIONALIDAD, function(x) {mean(is.na(x)) 
})
  
  df <- df %>%
  mutate(
    EDADFLLEG = ifelse(is.na(EDADFLLEG), "No procede", EDADFLLEG),
    TPOFLLEG = ifelse(is.na(TPOFLLEG), "No procede", TPOFLLEG),
    TPOFNACESP = ifelse(is.na(TPOFNACESP), "No procede", TPOFNACESP),
    NACNACIMESP = ifelse(is.na(NACNACIMESP), "No procede", NACNACIMESP)
  )
```

Las variables EDADFLLEG y TPOFLLEG miden la edad con la que un extranjero llego a españa y el tiempo que lleva residiendo respectivamente mientras que TPOFNACESP es el tiempo que lleva alguien con la nacionalidad española adquirida, cuando filtramos por no nacionales españoles y gente con nacionalidad española, vemos que desaparecen los NA lo cual es lógico puesto que un ciudadano español nacido en españa ya reside en españa desde que nació y por otro lado, todo ciudadano que no haya querido solicitar la nacionalidad española no le procede contestar cuanto años hace que la adquirio.

Finalmente NACNACIMESP mide si alguien tiene o no la nacionalidad española de nacimiento o la adquirio después, si no la han solicitado no procede contestar y por eso aparecen los NA.

```{r}
df_OCUPADOS <- df %>% 
  select(OCUPA,RELACT) %>% 
  filter((RELACT == "Trabajando a tiempo completo" | RELACT == "Trabajando a tiempo parcial"))

  sapply(df_OCUPADOS, function(x) {mean(is.na(x)) 
})
  
  df <- df %>%
  mutate(
    OCUPA = ifelse(is.na(OCUPA), "No procede", OCUPA)
  )
  
df_CONSTRUCCION <- df %>% 
  select(ANOANEDI,ANEDI) %>% 
  filter(ANEDI == "Después del año 2000")

  sapply(df_CONSTRUCCION, function(x) {mean(is.na(x)) 
})
  
table(df$FEDI,df$ANEDI)

df <- df %>% 
  select(-ANOANEDI & -ANEDI)

```

Que haya muchos NA es comprensible en el apartado de OCUPA puesto que si el entrevistado no se encuentra ocupado no puede contestar nada, respecto a ANONEDI solo recoge datos de construcción de vivienda a partir de los años 2000, por lo que no aporta información adicional relevante respecto a las variables ANEDI y FEDI, de hecho, ANEDI tampoco aporta más información que la variable FEDI, por lo que estas dos variables se pueden suprimir.

```{r}
NA_analisis <- sapply(df, function(x) {mean(is.na(x)) * 100
})
NA_analisis
```

Con esto hemos eliminado todos los valores ausentes del conjunto de datos, faltaría codificar todos los cambios realizados de forma que no afecte luego en fases posteriores del analisis.

### Cambios de tipo de variables

La variable periodo representa una variable de tipo fecha Año-Trimestre, aunque ahora aparece como una variable de tipo numérico. Por otro lado hemos estado trabajando con una gran cantidad de variables de tipo factor que actualmente aparecen como de tipo caracter y deben ser cambiadas, en la fase de codificación se pasarán a númerico para poder usados en análisis de correlación, modelos de regresión etc.

```{r}
rm(list=setdiff(ls(), "df"))
df$PERIODO <- gsub("^(.{4})(.{0,})", "\\10\\2", df$PERIODO)

columnas_int_factor <- c("TAMANO","REGVI","TIPOVIV","FEDI","NACHO","SEXO","EC","NACIM","COCINA","NAC","NACNACIMESP","NACIMPADRE","NACIMMADRE","OCUPA","PAREJA","SEXOPAR","NACPAR","ECPAR","HIJOSDEAMBOS","ESTUDIOS","FEDI")

df <- df %>% 
  mutate(PERIODO = yq(PERIODO)) %>% 
  mutate_if(is.character, factor) %>% 
  mutate_at(vars(columnas_int_factor), as.factor)

str(df)
```

Analizando los levels de las variables factor nos encontramos con países con código "966" y "555", que no aparecen en los diccionarios proporcionados en el INE y que por tanto se han debido de tratar de errores de escritura, por tanto vamos a filtrarlos.

```{r}
df <- df %>% 
  filter(PNACIMT != "966" & PNACT != "555" & PNACIMPADRET != "966" & PNACIMMADRET != "966") %>% 
  droplevels()

unique(df$ESTUDIOS)

str(df)
```

### Cambio nombre variables

Cambios de nombre de variables para mejorar la claridad de algunas variables

```{r}
df <- df %>% 
  rename(
    PROVINCIA = IDQ_PV,
    F_CONS_EDI = FEDI,
    PERS_HOGAR = TAMTOHO,
    NAC_HO = NACHO,
    PAIS_NACIM = PNACIMT,
    EDAD_LLEG_ESP = EDADFLLEG,
    TPO_LLEG_ESP =TPOFLLEG,
    PAIS_NAC = PNACT,
    PAIS_NAC_NACIM = PNACNACIMT,
    TPO_NAC_ESP = TPOFNACESP,
    PAIS_NACIM_PADRE = PNACIMPADRET,
    PAIS_NACIM_MADRE = PNACIMMADRET,
    RELAC_MIEMBROS = P01,
    ACTIVIDAD = RELACT,
)
```


### Recodificación de variables

En un inicio nuestro dataset presentaba un tipo de codificación ya establecido, el problema era la dificultad de interpretar el dataset y sus posibles relaciones entonces se decidió descodificar primero las variables para poder entender que significaba cada cosa de forma sencilla. Tras haber realizado una parte del proceso de limpieza del dataset, es necesario recodificarlo, esta vez acorde al tipo de codificación que queramos a la hora de poder hacer un buen análisis de detección de outliers y busqueda de correlaciones entre variables.

Las variables a codificar son aquellas de tipo categórico. Las variables categóricas se dividen en dos grupos: ordinales y cardinales. En las variables categóricas ordinales, las variables se pueden codificar acorde a un orden númerico ya que existe una jerarquia. a > b > c, en las variables cardinales por el contrario, no se aprecia un orden entre las variables: Andalucia !> Aragón. Esto es importante porque para cada caso las técnicas de codificación son distintas.

Como variables ordinales en este caso podemos considerar a TAMAÑO, ESTUDIOS, TIPOVIV, FEDI, mientras que el resto son cardinales.

```{r}
categoricas_ordinales <- c("TAMANO","TIPOVIV","F_CONS_EDI","ESTUDIOS")

value_to_exclude <- "No procede"  # Valor a excluir

df[, categoricas_ordinales] <- sapply(df[, categoricas_ordinales], function(x) {
  ifelse(x == value_to_exclude, "No procede", as.numeric(x))
})
df[, categoricas_ordinales] <- sapply(df[, categoricas_ordinales], function(x) as.numeric(factor(x)))

str(df)
```

```{r}
columnas_dummy <- c("REGVI","NAC_HO","SEXO","EC","NACIM","COCINA","NAC","NACNACIMESP","NACIMPADRE","NACIMMADRE","OCUPA","PAREJA","SEXOPAR","NACPAR","ECPAR","HIJOSDEAMBOS")


# Create dummy variables
dummy <- dummyVars(paste("~", paste(columnas_dummy,collapse = " + ")), data = df)

# Apply the dummy variables to the dataframe
df_dummies <- data.frame(predict(dummy, newdata = df))

df_merged <- cbind(df, df_dummies)

df_merged <- df_merged %>% 
  select(!(columnas_dummy))

str(df_merged)
NA_analisis <- sapply(df_merged, function(x) {mean(is.na(x)) * 100
})
NA_analisis 
```


