---
title: "Pruebas ProyectoAED2023"
output: html_document
date: "2023-10-12"
---

```{r, message = FALSE}
#librerias
library(readr)
library(readxl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(mapdata)
library(leaflet)
```

```{r}
hogar <- read.csv("./data/datos_hogares_2020/ECHHogares_2020.csv", sep = "\t")
persona <- read.csv("./data/datos_personas_2020/ECHPersonas_2020.csv", sep = "\t")
```

El siguiente bloque de código se encarga de reemplazar todos los términos con un diccionario asociado. Tarda bastante en ejecutarse, supongo que por la cantidad de filas y columnas y la longitud de lo que tiene que reemplazar. Lo dejo para todas las columnas, pero se puede especificar para que actúe sobre las que queramos.

```{r, message = FALSE}
dic <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", skip = 1, progress = F)

tab1 <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = "Tablas1", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab1) <- c("Cod", "Desc", "Var")
ind <- which(tab1$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab1[(ind[i]-1):nrow(tab1), "Var"] <- tab1[ind[i]-1, 3]
    tab1[(ind[i]-1):nrow(tab1), "New_Var"] <- tab1[ind[i]-1, 1]
  } else {
    tab1[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab1[ind[i]-1, 3]
    tab1[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab1[ind[i]-1, 1]
  }
}
I <- (!is.na(tab1$Cod != "Código") & tab1$Cod != "Código")
tab1 <- tab1[I, ]

J <- (!is.na(tab1$Desc))
tab1 <- tab1[J, ]

tab2 <- read_excel("./data/datos_hogares_2020/dr_ECHHogares_2020.xlsx", sheet = "Tablas2", col_names = FALSE, skip = 4)

# vamos a arreglar este data.frame para que quede más claro lo que contiene

names(tab2) <- c("Cod", "Desc", "Var")
ind <- which(tab2$Cod == "Código")

for (i in seq(1, length(ind))){
  if (is.na(ind[i+1])){
    tab2[(ind[i]-1):nrow(tab2), "Var"] <- tab2[ind[i]-1, 3]
    tab2[(ind[i]-1):nrow(tab2), "New_Var"] <- tab2[ind[i]-1, 1]
  } else {
    tab2[(ind[i]-1):(ind[i+1]-2), "Var"] <- tab2[ind[i]-1, 3]
    tab2[(ind[i]-1):(ind[i+1]-2), "New_Var"] <- tab2[ind[i]-1, 1]
  }
}
I <- (!is.na(tab2$Cod != "Código") & tab2$Cod != "Código")
tab2 <- tab2[I, ]

J <- (!is.na(tab2$Desc))
tab2 <- tab2[J, ]

tab <- full_join(tab1, tab2)

tab$Cod <- as.numeric(as.character(tab$Cod))

for (i in names(hogar)){
  #el vector pos es el que contiene las posiciones de tab que contienen info sobre esa variable
  pos <- which(tab$Var == i)
  #el if es porque hay variables que no están en la tabla
  if (length(pos)>0){
    #ahora tenemos que sustituir el código por lo que toca
    for (j in seq(1, length(pos))){
      #el vector cod contiene las posiciones de hogar que tienen el mismo código para así poder sustituirlos
      cod <- which(hogar[,i] == tab$Cod[pos[j]])
      hogar[cod, i] <- tab$Desc[pos[j]]
    }
  }
}

```

Vamos a tratar de realizar un primer análisis exploratorio del DataSet **hogar**. Para ello, en primer lugar observaremos las columnas del DataSet y el tipo de elementos que contienen

```{r}
str(hogar)
```
Además de un alista con las distintas columnas y sus tipos de datos, podemos generar un resumen con distintos estadísticos para cada una de las variables

```{r}
summary(hogar)
```
Esta función también nos permite observar qué columnas contienen NA's, información que nos será útil a futuro de cara a limpiar nuestro DataSet o trabajar con los datos

Como podemos observar, hay muchas columnas que contienen índices que no reflejan la información como tal, si no que hacen referencia a una escala externa, presente en otro documento. Además, hay ciertos nombres de variable que no son del todo claros, los cambiaremos para que sean más representativos. Lo que haremos a continuación será obtener la información real


```{r}
# En este chunK de código voy a poner, comentado para saber que hay que modificarlo o borrarlo, info relevante acerca de los campos, para no tener que mirarla en el fichero director

#IDENTIFICACIÓN DE LA VIVIENDA-----------------------------------------------------------------------------------------------------------

# PERIODO -> Periodo de recogida de la vivienda (formato -> aaaan; año + n-trimestre)
# TAMANO -> Tamaño del municipio (índice por habitantes -> valores en doc director)
# IDQ_PV -> Provincia (índices por porvincia -> valores en doc director)
# CA -> Comunidad autonoma (IDEM provincia)
# FACCAL -> Factor de elevación calibrado (formato numerico -> nnnnnn.nnnnnn)

#CARACTERÍSTICAS DE LA VIVIENDA----------------------------------------------------------------------------------------------------------

# REGVI -> Régimen de tenencia, es decir alquilada,, hipoteca, etc (índices por tipo -> valores en doc director)
# COCINA -> Disponibilidad de cocina (1 -> Sí ; 6 -> No)
# NHABVI -> Número de habitaciones
# METROSVI -> Metros cuadrados útiles en la vivienda

#CARACTERÍSTICAS DEL EDIFICIO------------------------------------------------------------------------------------------------------------

# TIPOVIV -> Tipo de edificio  (índices 1-6 -> valores en doc director)
# ANEDI -> Año de construcción (índices 1-9 -> valores en doc director)
# ANOANEDI -> Año de cosntrucción (solo valores del 20021 al 2020)
# FEDI -> Fecha de construcción (índices 01 - 11 -> valores en doc director)

#CARACTERÍSTICAS DEL HOGAR---------------------------------------------------------------------------------------------------------------

# TIP0HO -> Tipo de hogar (índices 1-16 -> valores en doc director)


```

Este bloque es el encargado de obtener la latitud y longitud de las distintas provincias (no es necesario ejecutarlo, el dataset está guardado en la carpeta data)

```{r, eval = FALSE}
library(geonames)

# List of provinces in Spain
provinces <- tab$Desc[which(tab$Var == "IDQ_PV")]

# Function to get latitude and longitude of a province
get_lat_long <- function(province) {
  aux <- GNsearch(name = province, country = "ES", fcode = "ADM2", username = "pavima")
  result <- c(aux$lat, aux$lng)
  return(result)
}

# Get latitude and longitude of all provinces
lat_long <- lapply(provinces, get_lat_long)

# Combine latitude and longitude into a data frame
lat_long_df <- do.call(rbind, lat_long)
```

Una vez realizada la consulta via API a través de geonames y obtemnidas las latitudes y longitudes de las provincias, arreglamos el dataframe y lo guardamos en la carpeta data para no tener que realizar un aconsulta a la API cada vez que ejecutemos el código

```{r, eval = FALSE}
lat_long_df <- data.frame(lat_long_df)
colnames(lat_long_df) = c("Latitud", "Longitud")

provinces <- tab$Desc[which(tab$Var == "IDQ_PV")]

lat_long_df <- lat_long_df %>%
  mutate(Provincias = c(provinces)) %>%
  select(Provincias, everything())

write.csv(lat_long_df, file = "./data/geolocalizacion_provincias.csv")
```


```{r}
province_geoloc <- read.csv("./data/geolocalizacion_provincias.csv")

selection <- hogar %>%
  select(IDQ_PV, METROSVI) %>%
  group_by(IDQ_PV)  %>%
  summarize(MeanSquareMeters = round(mean(METROSVI, na.rm = TRUE), 2)) %>%
  mutate(aux = "Media (m²):") %>%
  mutate(MeanSquareColRef = MeanSquareMeters) %>%
  unite(MeanSquareM, aux, MeanSquareMeters, sep = " ")

getColor <- colorNumeric(palette = "YlOrRd", domain = selection$MeanSquareColRef)

# Crear un mapa centrado en España
map_spain <- leaflet() %>%
  addTiles(urlTemplate = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png') %>%
  setView(lng = -3.7492, lat = 40.4637, zoom = 6) %>%
  addCircleMarkers(
    lat = province_geoloc$Latitud,
    lng = province_geoloc$Longitud,
    label = province_geoloc$Provincias,
    popup = selection$MeanSquareM,
    popupOptions = popupOptions(closeButton  = F),
    color = getColor(selection$MeanSquareColRef),
    group = "Media m² (2020)"
    )%>%

  addLegend(
    position = "bottomright",
    pal = getColor,
    values = selection$MeanSquareColRef,
    title = "Media m² (2020)",
    group = "Media m² (2020)"
    )%>%
  
  addLayersControl(overlayGroups = c("Media m² (2020)"))

# Mostrar el mapa
map_spain
```

```{r}
# an automatic legend derived from the color palette
df <- local({
  n <- 300; x <- rnorm(n); y <- rnorm(n)
  z <- sqrt(x ^ 2 + y ^ 2); z[sample(n, 10)] <- NA
  data.frame(x, y, z)
})
pal <- colorNumeric("OrRd", df$z)
leaflet(df) %>%
  addTiles() %>%
  addCircleMarkers(~x, ~y, color = ~pal(z), group = "circles") %>%
  addLegend(pal = pal, values = ~z, group = "circles", position = "bottomleft") %>%
  addLayersControl(overlayGroups = c("circles"))

# format legend labels
df <- data.frame(x = rnorm(100), y = rexp(100, 2), z = runif(100))
pal <- colorBin("PuOr", df$z, bins = c(0, .1, .4, .9, 1))
leaflet(df) %>%
  addTiles() %>%
  addCircleMarkers(~x, ~y, color = ~pal(z), group = "circles") %>%
  addLegend(pal = pal, values = ~z, group = "circles", position = "bottomleft") %>%
  addLayersControl(overlayGroups = c("circles"))

leaflet(df) %>%
  addTiles() %>%
  addCircleMarkers(~x, ~y, color = ~pal(z), group = "circles") %>%
  addLegend(pal = pal, values = ~z, labFormat = labelFormat(
    prefix = "(", suffix = ")%", between = ", ",
    transform = function(x) 100 * x
  ),  group = "circles", position = "bottomleft" ) %>%
  addLayersControl(overlayGroups = c("circles"))
```

```{r}
library(shiny)
library(leaflet)

ui <- fluidPage(
  leafletOutput("map"),
  h3("Variables de interés para caracterizar un hogar"),
  p("Las cualidades relevantes para descrivbir una casa son:"),
  tags$ul(
    tags$li("Ubicación"),
    tags$li("Tamaño"),
    tags$li("Número de habitaciones"),
    tags$li("Número de baños"),
    tags$li("Edad de la casa"),
    tags$li("Condición de la casa")
  ),
  h3("Referencias"),
  p("A continuación se proporcionan algunas de las páginas donde visualizar y adquirir casas en España:"),
  tags$ul(
    tags$li(a("https://www.tinsa.es", href = "https://www.tinsa.es")),
    tags$li(a("https://www.homeespana.com/", href ="https://www.homeespana.com/")),
    tags$li(a("https://www.idealista.com/", href ="https://www.idealista.com/"))
  )
)

server <- function(input, output, session) {
  output$map <- renderLeaflet({map_spain})
}

shinyApp(ui, server)


```

```{r}
library(shiny)
library(shinydashboard)
library(dplyr)

 ui <- dashboardPage(
    dashboardHeader(title = "Menú dinámico"),
    dashboardSidebar(
      sidebarMenu(

        menuItem("Proyecto AED 2023", tabName="title", icon = icon("star"))
      ),
      sidebarMenuOutput("menu")
    ),
    dashboardBody(tabItems(
      
      tabItem(tabName = "info",
              h1("Información del proyecto"),
               p("El objetivo de este proyecto es enfrentarse a un problema real de tratamiento de datos que abarque todas las etapas que se describen a lo largo de la asignatura. El proyecto se realiza en grupos de trabajo, lo que  permitire adquirir nuevas compencias relacionadas con el trabajo en equipo, distribución de tareas, puesta en común, resolución de problemas, responsabilidad dentro del grupo, etc."),
              fluidPage()
      ),
      tabItem(tabName = "plots", h2("Mapa interactivo"),
              fluidRow(column(width = 12, class = "well",
                              leafletOutput("map")))
      ),
      tabItem(tabName = "dashboard", h2("Contenido del dataset hogar"),
              DT::dataTableOutput("table1")),
      
      tabItem(tabName = "dashboard2", h2("Contenido del dataset personas"),
              DT::dataTableOutput("table2")))
    )
 )



  server <- function(input, output, session) {

    output$menu <- renderMenu({
      sidebarMenu(
        menuItem("Información", tabName = "info", icon = icon("info")),
        
        menuItem("Menú del Mapa", tabName = "plots", icon = icon("map")),

        menuItem("Datos de hogares", tabName="dashboard", icon = icon("table")),
        
        menuItem("Datos de personas", tabName="dashboard2", icon = icon("table"))
      )
    })

   output$table1 <- DT::renderDataTable({
    DT::datatable(hogar, options = list(scrollX = TRUE, scrollY = TRUE))
  })
    
    output$table2 <- DT::renderDataTable({
    DT::datatable(persona, options = list(scrollX = TRUE, scrollY = TRUE))
  })
    
    output$map <- renderLeaflet({map_spain})

  }

  shinyApp(ui, server)
```

```{r}
library(shiny)
library(DT)

ui <- fluidPage(
  DT::dataTableOutput("table")
)

server <- function(input, output) {
  output$table <- DT::renderDataTable({
    # Replace "data" with your data frame
    DT::datatable(hogar, options = list(scrollX = TRUE, scrollY = TRUE))
  })
}

shinyApp(ui, server)

```




